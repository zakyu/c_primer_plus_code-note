# 作用域
块作用域 函数作用域 函数原型作用域 文件作用域

# 链接
外部链接 内部链接 无链接

# 存储期

自动存储期、静态存储期、动态分配存储期、线程存储期

## 自动存储期

块作用域的变量通常都具有自动存储期。

当程序进入定义这些变量的块时，为这些变量分配内存；
当退出这个块时，释放刚才为变量分配的内存。

变长数组稍有不同，它们的存储期从声明处到块末尾。

## 静态存储期

在程序的执行期间一直存在。

文件作用域变量具有静态存储期。

对于文件作用域变量，关键字`static`表明了其链接属性，而非存储期。

无论是内部链接还是外部链接，所有的文件作用域都具有静态存储期。

块作用域变量也能具有静态存储期。
创建这样的变量，要把变量声明在块中，且在声明前面加上关键字`static`。

## 动态分配存储期

## 线程存储期

线程存储期用于并发程序设计，程序执行可被分为多个线程。

具有线程存储期的对象，从被声明时到线程结束一直存在。

---
# 存储类别

## 自动变量

属于自动存储类别的变量具有自动存储期、块作用域且无链接。

默认情况下，声明在块或函数头中的任何变量都属于自动存储类别。也可以显式使用关键字`auto`（和C++不兼容）。

自动变量不会初始化，除非显式初始化它。

## 寄存器变量

使用存储类型说明符`register`可声明寄存器变量。

与普通变量相比，访问和处理寄存器变量的速度更快。

由于寄存器变量存储在寄存器而非内存中，所有无法获取寄存器变量的地址。

声明寄存器变量更像是一种请求。编译器必须根据寄存器或最快可用内存的数量衡量请求，可能会直接忽略请求。此时，寄存器变量就跟普通自动变量一样了，但是仍然不能对该变量使用地址运算符。

可声明为`register`的数据类型有限。

## 静态变量

静态的意思是该变量的内存地址不变，而不是它的值不变。

如果未显式初始化静态变量，会被初始化为0值。

静态变量和外部变量在程序被载入内存时声明。

### 块作用域的静态变量

不能在函数的形参中使用`static`。

“局部静态变量”是描述具有块作用域的静态变量的另一个术语。

### 外部链接的静态变量

外部链接的静态变量具有文件作用域、外部链接和静态存储期。

该类别有时称为外部存储类别，属于该类别的变量称为外部变量。把变量的定义性声明放在所有函数的外面便创建了外部变量。

- 为了指出函数使用了外部变量，可以在函数中用关键字`extern`再次声明（再次声明时数组大小可以省略）。

- 如果一个源代码文件使用的外部变量定义在另一个源代码文件中，则必须用`extern`在该文件中声明该变量。

外部变量的作用域：从声明处到文件结尾。

外部变量默认自动初始化为0值。

文件作用域变量显式初始化时，只能使用常量表达式初始化。
只要不是变成数组，`sizeof`表达式可被是为常量表达式。

```c  
int tern = 1;

void main()
{
    extern int tern;
    ...
}
```
`tern`被声明了两次。
第一次声明为变量预留了存储空间，该声明构成了变量的定义。
第二次声明只是告诉编译器使用之前已创建的`tern`变量，所以这不是定义。
第一次声明被称为定义式声明。
第二次声明被称为引用式声明。

关键字`extern`表明该声明不是定义，它指示编译器去别处查询其定义。

不能用关键字`extern`创建外部定义，只能用它来引用现有的外部定义。

外部变量只能初始化一次，且必须在定义该变量时进行。

### 内部链接的静态变量

在所有函数外部用存储类别说明符`static`定义的变量。

该存储类别的变量具有静态存储期、文件作用域和内部链接。

普通的外部变量可用于同一程序中任意文件中的函数，但是内部链接的静态变量只能用于同一个文件中的函数。

可以使用存储类型说明符`extern`，在函数中重复声明任何具有文件作用域的变量。这样的声明不会改变其链接属性。

# 多文件

有时，多个单独的源代码文件可能要共享一个外部变量。

C通过一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享。

注意，如果外部变量定义在一个文件中，那么其他文件在使用该变量之前必须先引用式声明它。

也就是说，在某个文件中对外部变量进行定义式声明只是单方面允许其他文件使用该变量，其他文件在引用式声明之前不能直接使用它。

# 存储类别说明符

auto、register、static、extern、_Thread_local、typedef

## typedef

`typedef`关键字与任何内存存储无关，把它归于此类有一些语法上的原因。

在绝大多数情况下，不能在声明中使用多个存储类别说明符，所以不能使用多个存储类别说明符作为`typedef`的一部分。

唯一例外的是`_Thread_local`,它可以和`static`或`extern`一起使用。

## auto

`auto`说明符表面变量是自动存储期，只能用于块作用域的变量声明中。

由于在块中声明的变量本身就具有自动存储期，所有使用使用`auto`说明符主要是为了明确表达要使用与外部变量同名的局部变量的意图。

## register

`register`说明符也只用于块作用域的变量，它把变量归为寄存器存储类别，请求最快速度访问该变量。同时，还保护该变量的地址不被获取。

## static

用`static`说明符创建的对象具有静态存储期，载入程序时创建对象，当程序结束时对象消失。

如果`static`用于文件作用域声明，作用域受限于该文件。具有内部链接。

如果`staitc`用于块作用域声明，作用域则受限于该块。无链接。只要程序在运行对象就存在并保留其值，但是只有在执行块内的代码时，才能通过标识符访问。

## extern

`extern`说明符表明声明的变量定义在别处。

如果包含`extern`的声明具有文件作用域，则引用的变量必须具有外部链接。

如果包含`extern`的声明具有块作用域，则引用的变量可能具有外部链接或内部链接，这取决于该变量的定义式声明。

# 存储类别和函数

外部函数（默认）、静态函数、内联函数

外部函数可以被其他文件的函数访问

静态函数只能用于其定义所在的文件

通常做法：用`extern`关键字声明定义在其他文件中的函数。这样做表明当前文件中使用的函数被定义在别处。除非使用`static`关键字，否则一般函数声明都默认为`extern`。

# malloc() free()

# calloc()

# 存储理想模型

程序把它可用的内存分为3部分
- 一部分供具有外部链接、内部链接、无连接的静态变量使用；
- 一部分供自动变量使用；
- 一部分供动态内存分配。

静态存储类别所用的内存数量在编译时确定，只要程序还在运行，就可访问储存在该部分的数据。该类别的变量在程序开始执行时被创建，在程序结束时被销毁。

自动存储类别的变量在程序进入变量定义所在块时存在，在程序离开块时销毁。随着程序调用函数和函数结束，自动变量所用的内存数量也相应地增加和减少。这部分内存通常作为栈来处理，新创建的变量按顺序加入内存，然后以相反顺序销毁。

动态分配的内存在调用`malloc()`或相关函数时存在，在调用`free()`函数后释放。这部分内存由程序员管理，通常被称为内存堆或自由内存。内存块可以在一个函数中创建，在另一个函数中销毁。因为这样，未使用的内存块分散在已使用的内存块之间。另外，使用动态内存通常比使用栈内存慢。

# ANSI C 类型限定符

`const`、`volatile`、`restrict`、`_Atomic`

## 类型限定符幂等性

C99为类型限定符增加了一个新属性：它们是幂等的。可以在一条声明中多次使用一个限定符，多余的限定符将被忽略。

```c
const const const int n = 6; // 与 const int n = 6; 相同</code>
```

有了这个属性，可以编写类似下面的代码：
```c
typedef const int zip;
const zip q = 0;
```

## const

以`const`关键字声明的对象，其值不能通过赋值或递增、递减来修改。

### 在指针和形参中使用 const

const 放在 * 左侧任意位置，限定了指针指向的数据不能改变；
const 放在 * 右侧，限定了指针本身不能改变。

ANSI C库遵循：如果一个指针仅用于给函数访问值，应将其声明为一个指向`const`限定类型的指针；如果要用指针更改主调函数中的数据，就不用。

### 对全局数据使用 const

文件间共享`const`数据采用的两个策略。

1. 遵循外部变量的常用规则，即在一个文件中使用定义式声明，在其他文件中使用引用式声明。

2. 把 const 变量放在一个头文件中，然后在其他文件中包含该头文件。实际上，这种方案相当于给每个文件提供了一个单独的数据副本。由于每个副本只对该文件可见，所以无法用这些数据和其他文件通信。这些数据是重复的。

## volatile（涉及编译器优化）

`volatile`限定符告知计算机，代理（而不是变量所在的程序）可以改变该变量的值。通常，它被用于硬件地址以及在其他程序或同时运行的线程中共享数据。

可以同时用`const`和`volatile`限定一个值。

## restrict（涉及编译器优化）

`restrict`关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。

## _Atomic

并发程序设计把程序执行分成可以同时执行的多个线程。

如何管理访问相同数据的不同线程？C11通过包含可选的头文件stdatomic.h和threads.h，提供了一些可选的管理方法。

原子类型要通过各种宏函数来访问。

当一个线程对一个原子类型的对象执行原子操作时，其他线程不能访问该对象。
